<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
<meta name="google-site-verification" content="ZuPSfZpWtpoO0Dlfq7CH6xYR_DgNEfn52UQLsdxRb_Y" />


  <link rel="apple-touch-icon" sizes="180x180" href="/theme-images/apple-touch-icon-cat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/theme-images/favicon-32x32-cat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/theme-images/favicon-16x16-cat.png">
  <link rel="mask-icon" href="/theme-images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="答辩结束后，终于开始入坑MIT6.828，正儿八经地学一下操作系统。使用的是2018年秋季的课程，现在好像改了，不叫这个名字了，这些都无所谓了。这里是官网。写这个东西也只是想让自己每次做完后记录一下，不然以后时间长了又忘了。   由于网上已经有很多人做了这个课程，也写了笔记，所以在我自己的笔记里，只会按着Lab，写一些我自己遇到的坑，或者自己感觉重要的东西，不会每个问题都记录。这篇文章会记录实验环">
<meta property="og:type" content="article">
<meta property="og:title" content="6.828笔记 Lab1: Booting a PC">
<meta property="og:url" content="http://example.com/2021/06/18/6-828%E7%AC%94%E8%AE%B0-Lab1-Booting-a-PC/index.html">
<meta property="og:site_name" content="老约翰中医">
<meta property="og:description" content="答辩结束后，终于开始入坑MIT6.828，正儿八经地学一下操作系统。使用的是2018年秋季的课程，现在好像改了，不叫这个名字了，这些都无所谓了。这里是官网。写这个东西也只是想让自己每次做完后记录一下，不然以后时间长了又忘了。   由于网上已经有很多人做了这个课程，也写了笔记，所以在我自己的笔记里，只会按着Lab，写一些我自己遇到的坑，或者自己感觉重要的东西，不会每个问题都记录。这篇文章会记录实验环">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-18T08:38:00.000Z">
<meta property="article:modified_time" content="2021-08-08T14:43:43.938Z">
<meta property="article:author" content="Roadshop">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/06/18/6-828%E7%AC%94%E8%AE%B0-Lab1-Booting-a-PC/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>6.828笔记 Lab1: Booting a PC | 老约翰中医</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">老约翰中医</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">实验环境</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-1"><span class="nav-number">2.</span> <span class="nav-text">Lab 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PC%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">2.1.</span> <span class="nav-text">PC的物理地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BIOS"><span class="nav-number">2.2.</span> <span class="nav-text">BIOS</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Roadshop</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NoobZang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NoobZang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:roadshop7@outlook.com" title="E-Mail → mailto:roadshop7@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/06/18/6-828%E7%AC%94%E8%AE%B0-Lab1-Booting-a-PC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Roadshop">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老约翰中医">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.828笔记 Lab1: Booting a PC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-18 16:38:00" itemprop="dateCreated datePublished" datetime="2021-06-18T16:38:00+08:00">2021-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/6-828/" itemprop="url" rel="index"><span itemprop="name">6.828</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>答辩结束后，终于开始入坑MIT6.828，正儿八经地学一下操作系统。使用的是2018年秋季的课程，现在好像改了，不叫这个名字了，这些都无所谓了。这里是<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">官网</a>。写这个东西也只是想让自己每次做完后记录一下，不然以后时间长了又忘了。  </p>
<p>由于网上已经有很多人做了这个课程，也写了笔记，所以在我自己的笔记里，只会按着Lab，写一些我自己遇到的坑，或者自己感觉重要的东西，不会每个问题都记录。这篇文章会记录实验环境的准备和Lab1里的一些内容。在我做的过程中，大量参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zsmumu/">此大神的笔记</a>，在此表达感谢！</p>
<a id="more"></a>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>本来不想开虚拟机，就在网上找了一篇使用WSL2的教程，结果做着做着出问题了，所以最后还是换成了虚拟机。用的是ubuntu18.04，虚拟机的话就比较好弄，按着<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/tools.html">官网给出的操作</a>做，或者自己在网上找教程都行。主要是下载他的QEMU模拟器，下载了以后运行<code>make &amp;&amp; make install</code>的时候会报各种错，直接网上搜，缺啥东西直接下载就行了，其中有两个是要修改源文件，include一点东西。都可以直接搜报错信息，网上都有。</p>
<h1 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h1><p>下载jos到lab后，就可以运行了。先记录几个常用的命令。</p>
<ul>
<li>开机：在lab目录下，终端输入<code>make qemu</code></li>
<li>调试：在lab目录下，一个终端输入<code>make qemu-gdb</code>，另一个终端输入<code>make gdb</code></li>
<li>关机：在开启的操作系统里先输入<code>ctrl+a</code>，然后再按<code>x</code></li>
</ul>
<h2 id="PC的物理地址"><a href="#PC的物理地址" class="headerlink" title="PC的物理地址"></a>PC的物理地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\</span><br><span class="line"></span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>从0x00000000到0x000FFFFF的640KB区域为Low memory，是早期PC可以使用的RAM。硬件保留的从 0x000A0000到0x000FFFFF的384KB区域用于特殊用途，例如视频显示缓冲区和非易失性存储器中保存的固件。其中最重要的是从0x000F0000到0x000FFFFF的64KB的BIOS。</p>
<h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><ul>
<li>单步调试：<code>si</code><br>开始调试后，输入<code>si</code>，进行第一步，显示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj&#x2F;kern&#x2F;kernel</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6ac8</span><br><span class="line">0x0000e05b in ?? ()</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以看出，第一条指令的地址是0x000ffff0。在上图中，就是BIOS ROM中的一部分。QEMU 模拟了8088处理器的启动，启动电源时，处理器进入实模式并且将CS设置为0xf000，将IP设置为0xfff0。机器要运行的地址为CS\*16+IP。也就是CS左移一位，再加上IP，即0x000ffff0。这样一开机，BIOS就取得了机器的控制权。BIOS 运行时，检查硬件，进行各种初始化，例如VGA显示。完成后，搜索可引导设备，例如软盘，硬盘驱动器或CD-ROM。 最终，BIOS在找到可引导磁盘时，会从磁盘读取boot loader并将控制权转移给boot loader。</span><br><span class="line"></span><br><span class="line">## The Boot Loader</span><br><span class="line">当BIOS找到可引导的软盘或硬盘时，它将512字节的引导扇区加载到物理地址0x7c00至0x7dff的内存中，这部分在上图中的Low Memory部分，然后使用jmp指令将CS:IP设置为0000:7c00，地址为0x00007c00。</span><br><span class="line">* 设置断点：&#96;b *addr&#96;，&#96;addr&#96;是以0x开头的地址；或者是&#96;b function&#96;，&#96;function&#96;是函数名</span><br><span class="line">* 跳转到断点：打了断点后，输入&#96;c&#96;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">boot loader包括两部分，分别是&#96;boot&#x2F;boot.S&#96;和&#96;boot&#x2F;main.c&#96;。&#96;obj&#x2F;boot&#x2F;boot.asm&#96;是编译boot loader 后的反汇编。&#96;obj&#x2F;boot&#x2F;boot.asm&#96;里一开始就是&#96;00007c00 &lt;start&gt;:&#96;，说明地址确实是0x7c00。  </span><br><span class="line">&#96;boot&#x2F;boot.S&#96;里前面进行了一系列的操作，目的是将处理器从实模式切换到32位保护模式，这样能访问大于1MB 的物理地址空间。最后会&#96;call bootmain&#96;，即进入&#96;boot&#x2F;main.c&#x2F;bootmain&#96;。  </span><br><span class="line">&#96;boot&#x2F;main.c&#96;的主要作用是从硬盘中读取内核。首先将磁盘中0地址开始的512\*8个byte,即4k的elf header读入0x10000地址。注意，此地址还是在Low Memory中。然后再根据elf header将kernel的每个segment读入内存。最后通过&#96;ELFHDR-&gt;e_entry&#96;进入ELF文件的进入点，即内核。  </span><br><span class="line"></span><br><span class="line">&#96;boot&#x2F;main.c&#96;做的事情：</span><br><span class="line">* 从硬盘中将kernel的elf header读入内存</span><br><span class="line">* 根据elf header和program header table提供的信息，将kernel的每个segment读入内存</span><br><span class="line">* 进入kernel</span><br><span class="line">  </span><br><span class="line">操作：  </span><br><span class="line">* 查看某个内存地址开始的&#96;N&#96;个字的十六进制内容：&#96;x&#x2F;Nx addr&#96;，&#96;N&#96;缺省时，为查看&#96;addr&#96;处1个字的十六进制。把第二个&#96;x&#96;换成&#96;i&#96;时，为查看指令。把第二个&#96;x&#96;换成&#96;s&#96;时，为查看字符串。  </span><br><span class="line"></span><br><span class="line">在刚进入&#96;boot&#x2F;main.c&#96;时，还没有加载elf header时，查看0x10000处的内容，为全0。跳转到加载了elf header但没有加载segment的位置后，查看0x10000，有内容。但是0x100000处为全0。跳转到加载完segment后的地方，查看0x100000，已经有内容了。最后进入内核的汇编代码为</span><br></pre></td></tr></table></figure>
call   *0x10018<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即跳转到地址为0x10018的内存里面的内容。查看0x10018的内容，为：</span><br></pre></td></tr></table></figure>
(gdb) x/x 0x10018<br>0x10018:    0x0010000c<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">即入口在0x100000后一点的地方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**总结：从开机到进入操作系统的过程：**</span><br><span class="line">**1. 运行BIOS里面的内容，检查硬件，最后BIOS会加载boot loader到Low Memory处**</span><br><span class="line">**2. 进入boot loader，将处理器从实模式切换到32位保护模式，并把elf header读入Low Memory**</span><br><span class="line">**3. 根据elf header和program header table提供的信息，将kernel的每个segment读入Extended Memory，最后通过ELFHDR-&gt;e_entry进入内核**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## The Kernel</span><br><span class="line">在本文中主要需要看的是&#96;kern&#x2F;entry.S&#96;和&#96;kern&#x2F;init.c&#96;，&#96;obj&#x2F;kern&#x2F;kernel.asm&#96;是kernel的反汇编。  </span><br><span class="line"></span><br><span class="line">### 虚拟地址映射</span><br><span class="line">操作系统内核通常被链接到非常高的虚拟地址（查看&#96;obj&#x2F;kern&#x2F;kernel.asm&#96;，就可以发现kernel被链接到0xf0100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。 但是实际上无法达到0xf0100000，所以使用地址映射，将0xf0100000（内核代码期望运行的链接地址）映射到物理地址0x00100000。总体上会把0xf0000000到0xf0400000映射到物理地址0x00000000到0x00400000。  </span><br><span class="line">&#96;kern&#x2F;entry.S&#96;前面一部分就是做的这个事情。执行&#96;mov %eax,%cr0&#96;后，0xf0100000的数据从0变成了与0x100000的数据一致，这说明，虚拟地址0xf0100000已经被映射到了0x100000。  </span><br><span class="line"></span><br><span class="line">### 调用栈</span><br><span class="line">这里先记录一下调用栈的过程。  </span><br><span class="line">内存中有一个栈空间，栈底在上面，地址大，栈顶在下面，地址小。每一个函数都有自己的栈空间。介绍三个寄存器，分别是&#96;eip(Instruction Pointer)&#96;，&#96;ebp(Base Pointer)&#96;和&#96;esp(Stack Pointer)&#96;，意思是下一条指令的地址、栈底地址和栈顶地址。  </span><br><span class="line">函数调用时，比如a函数调用b函数，b的声明为&#96;void b(int x, int y)&#96;，则会在a的栈空间内反向把参数压入栈中，即先压入&#96;y&#96;，再压入&#96;x&#96;。调用b的时候，也就是&#96;call b&#96;，根据[课程提供的文件](https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.828&#x2F;2018&#x2F;lec&#x2F;l-x86.pdf)，&#96;call&#96;的时候先把&#96;eip&#96;中的值放入栈中，再把要&#96;call&#96;的地址放入&#96;eip&#96;，则下一条指令就跳过去了。进入b函数后，先把此时的&#96;ebp&#96;的值压入栈中，即a函数的栈底的地址，然后把&#96;esp&#96;的值赋给&#96;ebp&#96;，即让&#96;ebp&#96;指向b函数的基址。类似于这样：</span><br></pre></td></tr></table></figure>
…<br>a上面的栈空间<br>y<br>x<br>调用前eip的值，即返回a函数后的下一条指令的地址(2)<br>之前的ebp值，即a函数的栈底的地址(1)<br>&lt;———————————-(esp)(ebp)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">此时，&#96;esp&#96;和&#96;ebp&#96;指向相同的地址。如果继续执行，则&#96;esp&#96;减小，&#96;ebp&#96;不动。执行完返回时，会出栈到&#96;ebp&#96;的位置，即栈顶为(1)，然后&#96;pop %ebp&#96;，即把当前栈顶的内容(1)给&#96;ebp&#96;并弹出此内容，此时&#96;ebp&#96;就是a函数的栈底的地址。最后&#96;ret&#96;，即&#96;pop %eip&#96;，意思是把(2)的内容给&#96;eip&#96;，现在就能返回了。返回后的下一条地址就是(2)，&#96;ebp&#96;仍然指向之前a函数的栈底。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回到Lab1。上面讲到虚拟地址映射，映射后，&#96;kern&#x2F;entry.S&#96;又做了一些操作后&#96;call    i386_init&#96;，即进入&#96;kern&#x2F;init.c&#x2F;i386_init&#96;。在&#96;kern&#x2F;init.c&#x2F;i386_init&#96;里面有一句&#96;test_backtrace(5);&#96;，&#96;test_backtrace&#96;的代码为：</span><br></pre></td></tr></table></figure>
// Test the stack backtrace function (lab 1 only)<br>void<br>test_backtrace(int x)<br>{<br>  cprintf(“entering test_backtrace %d\n”, x);<br>  if (x &gt; 0)<pre><code>  test_backtrace(x-1);</code></pre>
  else<pre><code>  mon_backtrace(0, 0, 0);</code></pre>
  cprintf(“leaving test_backtrace %d\n”, x);<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以看出，分别会递归执行5，4，3，2，1，0，在0的时候调用&#96;mon_backtrace&#96;。  </span><br><span class="line">每个函数会在自己的栈空间内做一些操作。前5次每次调用的函数栈空间为：（从上往下地址减少）</span><br></pre></td></tr></table></figure>
上一个ebp地址<br>esi<br>ebi<br>不知道是啥，直接空出来的<br>不知道是啥，直接空出来的<br>当前调用的数字<br>当前调用的数字-1<br>返回值，即调用下个函数结束后的返回地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实验里&#96;b *0x10000c&#96;，经过几次&#96;si&#96;后，进入虚拟地址。打断点&#96;b *0xf010006a&#96;，此时54321走完了，0不需要跳了，需要执行进入&#96;mon_backtrace&#96;的代码。前5次每次函数使用了8个栈空间，5\*8&#x3D;40，现在调试的时候0用了3个。然后：</span><br></pre></td></tr></table></figure>
(gdb) x/45x $esp<br>0xf010ff30: 0xf0111308  0x00000001  0xf010ff58  0xf01000a1<br>0xf010ff40: 0x00000000  0x00000001  0xf010ff78  0xf010004a<br>0xf010ff50: 0xf0111308  0x00000002  0xf010ff78  0xf01000a1<br>0xf010ff60: 0x00000001  0x00000002  0xf010ff98  0xf010004a<br>0xf010ff70: 0xf0111308  0x00000003  0xf010ff98  0xf01000a1<br>0xf010ff80: 0x00000002  0x00000003  0xf010ffb8  0xf010004a<br>0xf010ff90: 0xf0111308  0x00000004  0xf010ffb8  0xf01000a1<br>0xf010ffa0: 0x00000003  0x00000004  0x00000000  0xf010004a<br>0xf010ffb0: 0xf0111308  0x00000005  0xf010ffd8  0xf01000a1<br>0xf010ffc0: 0x00000004  0x00000005  0x00000000  0xf010004a<br>0xf010ffd0: 0xf0111308  0x00010094  0xf010fff8  0xf01000f4<br>0xf010ffe0: 0x00000005<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 查看寄存器表示的内容作为地址的值：&#96;x&#x2F;x $eax&#96;，&#96;eax&#96;为寄存器的名字，也可以为&#96;ebp&#96;，&#96;esp&#96;等。但是要注意，此命令是查看寄存器内的值作为地址，在内存中的值</span><br><span class="line">* 查看寄存器的值：&#96;info registers&#96;，查看好多寄存器的值，&#96;info registers eax&#96;只查看&#96;eax&#96;寄存器的值。简写分别为&#96;i r&#96;和&#96;i r eax&#96;  </span><br><span class="line"></span><br><span class="line">前面的是地址，后面是值。上面讲到，调试时0已经用了3个，其他54321分别使用了8个，所以地址低的0xf010ff58是调用0时上一个ebp地址，即1的ebp。  </span><br><span class="line">再往上数8个就是真实的那个地方。这个地方存的内容为0xf010ff78，即2的ebp。再根据前面的地址</span><br><span class="line">0xf010ff50可以算出0xf010ff78的地址为0xf010ff58，和前面的0的放的内容一致。  </span><br><span class="line"></span><br><span class="line">这里记录一个坑，在实验里面让补充一个函数，使得能够在&#96;mon_backtrace&#96;中看到已有的&#96;ebp&#96;地址之类的。里面调用了&#96;ebp &#x3D; read_ebp();&#96;，&#96;read_ebp()&#96;的代码：</span><br></pre></td></tr></table></figure>
static inline uint32_t<br>read_ebp(void)<br>{<br>  uint32_t ebp;<br>  asm volatile(“movl %%ebp,%0” : “=r” (ebp));<br>  return ebp;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">里面是有一句汇编代码，意思是把寄存器&#96;ebp&#96;的值给自己定义的&#96;ebp&#96;。我一开始搞混了，以为的是栈空间内存上此函数的&#96;ebp&#96;的值，即上一个调用它的函数的栈地址。我就说这不是跑到上一个调用它的函数去了吗，最后才发现，是当前寄存器&#96;ebp&#96;的值，即真正指向此函数栈基址的寄存器，而不是栈空间内的值。</span><br></pre></td></tr></table></figure>
上一个ebp地址(2)<br>esi<br>ebi<br>不知道是啥，直接空出来的<br>不知道是啥，直接空出来的<br>当前调用的数字<br>当前调用的数字-1<br>返回值，即调用下个函数结束后的返回地址</li>
</ul>
<p>——————上面是a函数，下面是b函数，a函数调用b函数———————–<br>上一个ebp地址(1)<br>esi<br>ebi<br>不知道是啥，直接空出来的<br>不知道是啥，直接空出来的<br>当前调用的数字<br>当前调用的数字-1<br>返回值，即调用下个函数结束后的返回地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时得到的&#96;ebp&#96;是(1)的地址，通过&#96;prev &#x3D; (uint32_t *)ebp;&#96;得到指向(1)的指针，&#96;prev[0]&#96;就是(1)的内容，&#96;prev[1]&#96;是b函数结束后的返回地址，&#96;prev[2,3,4]&#96;之类的就是a函数传给b函数的参数。  </span><br><span class="line">最后写debug的代码没咋看懂，基本是抄的，但是结果看懂了。里面两行比较重要的代码：</span><br></pre></td></tr></table></figure>
<p>ebp = <em>prev;<br>prev = (uint32_t</em>)ebp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;ebp&#96;本是(1)的地址，是&#96;uint32_t&#96;，数值型。&#96;prev&#96;是指向(1)的指针，&#96;ebp &#x3D; *prev;&#96;使得&#96;ebp&#96;得到了(1)的内容，为(2)的地址。然后循环。最后debug结果为：</span><br></pre></td></tr></table></figure>
<p>Stack backtrace:<br>ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308<br>     kern/init.c:18: test_backtrace+56 //mon_backtrace<br>ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308<br>     kern/init.c:16: test_backtrace+97  //0<br>ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308<br>     kern/init.c:16: test_backtrace+97  //1<br>ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308<br>     kern/init.c:16: test_backtrace+97  //2<br>ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308<br>     kern/init.c:16: test_backtrace+97  //3<br>ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308<br>     kern/init.c:16: test_backtrace+97  //4<br>ebp f010ffd8  eip f01000f4  args 00000005 00001aac 00000640 00000000 00000000<br>     kern/init.c:39: i386_init+78  //5<br>ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003<br>     kern/entry.S:83: <unknown>+0  //bootmain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0的&#96;ebp&#96;的地址为0xf010ff38，和上面的能够对应起来。执行到&#96;mon_backtrace&#96;后：</span><br></pre></td></tr></table></figure>
<p>(gdb) x/x 0xf010ff18<br>0xf010ff18: 0xf010ff38</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试一下&#96;bootmain&#96;的&#96;ebp&#96;：</span><br></pre></td></tr></table></figure>
<p>(gdb) x/x 0xf010fff8<br>0xf010fff8: 0x00000000</p>
<p>```<br>说明整个程序的基地址为0。  </p>
<p>最后在lab目录下运行<code>make grade</code>，得到打分结果。可能运行会出错，大神的笔记里面也有解决方案。最后终于得到了5个OK，Lab1应该算是结束了。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/04/%E5%AF%B9pytorch%E9%87%8CLSTM%E7%9A%84%E7%90%86%E8%A7%A3/" rel="prev" title="对pytorch里LSTM的理解">
                  <i class="fa fa-chevron-left"></i> 对pytorch里LSTM的理解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/21/6-828%E7%AC%94%E8%AE%B0-Lab-2-Memory-Management/" rel="next" title="6.828笔记 Lab 2: Memory Management">
                  6.828笔记 Lab 2: Memory Management <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roadshop</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
